<?php

namespace App\Controller;

use Doctrine\ORM\EntityManagerInterface;
use Symfony\Bundle\FrameworkBundle\Controller\AbstractController;
use Symfony\Component\HttpFoundation\JsonResponse;
use Symfony\Component\HttpFoundation\Request;
use Symfony\Component\Routing\Annotation\Route;

#[Route('/api/usuario')]
class MisDietasController extends AbstractController
{
    private EntityManagerInterface $entityManager;

    public function __construct(EntityManagerInterface $entityManager)
    {
        $this->entityManager = $entityManager;
    }

    #[Route('/mis-dietas/{usuarioId}', name: 'api_usuario_mis_dietas', methods: ['GET'])]
    public function getMisDietas(int $usuarioId, Request $request): JsonResponse
    {
        try {
            // ✅ Obtener token del header
            $authHeader = $request->headers->get('Authorization');

            if (!$authHeader || !preg_match('/^Bearer\s+(.+)$/', $authHeader, $matches)) {
                return $this->json([
                    'success' => false,
                    'error' => 'Token no proporcionado'
                ], 401);
            }

            $token = $matches[1];

            // ✅ Validar token (verificar que no está expirado)
            $payload = $this->decodeJwt($token);
            if (!$payload) {
                return $this->json([
                    'success' => false,
                    'error' => 'Token inválido o expirado'
                ], 401);
            }

            // ✅ Verificar que el usuario del token es el solicitado
            // Buscar email en múltiples claims posibles (username, email, sub)
            $emailFromToken = $payload['username'] ?? $payload['email'] ?? $payload['sub'] ?? null;

            // Obtener ID del usuario por email
            $usuarioFromDb = $this->entityManager
                ->getConnection()
                ->executeQuery(
                    "SELECT id FROM usuarios WHERE email = ?",
                    [$emailFromToken]
                )
                ->fetchOne();

            if (!$usuarioFromDb || (int)$usuarioFromDb !== (int)$usuarioId) {
                return $this->json([
                    'success' => false,
                    'error' => 'No tienes permiso para ver estas dietas'
                ], 403);
            }

            // ✅ Query para dietas ASIGNADAS
            $sqlAsignadas = "
                SELECT 
                    d.id,
                    d.nombre,
                    d.descripcion,
                    d.calorias_totales,
                    d.proteinas_totales,
                    d.carbohidratos_totales,
                    d.grasas_totales,
                    d.creador_id,
                    e.nombre as entrenador_nombre,
                    e.apellidos as entrenador_apellidos,
                    DATE_FORMAT(d.fecha_creacion, '%d/%m/%Y') as fecha_asignacion
                FROM dietas d
                INNER JOIN entrenadores e ON d.creador_id = e.id
                WHERE d.asignado_a_usuario_id = :usuarioId
                AND d.creador_id IS NOT NULL
                ORDER BY d.fecha_creacion DESC
            ";

            $stmtAsignadas = $this->entityManager->getConnection()->prepare($sqlAsignadas);
            $resultAsignadas = $stmtAsignadas->executeQuery(['usuarioId' => $usuarioId]);
            $dietasAsignadas = $resultAsignadas->fetchAllAssociative();

            // ✅ Query para dietas CREADAS
            $sqlCreadas = "
                SELECT 
                    d.id,
                    d.nombre,
                    d.descripcion,
                    d.calorias_totales,
                    d.proteinas_totales,
                    d.carbohidratos_totales,
                    d.grasas_totales,
                    DATE_FORMAT(d.fecha_creacion, '%d/%m/%Y') as fecha_creacion
                FROM dietas d
                WHERE (d.asignado_a_usuario_id = :usuarioId OR d.asignado_a_usuario_id IS NULL)
                AND d.creador_id IS NULL
                ORDER BY d.fecha_creacion DESC
            ";

            $stmtCreadas = $this->entityManager->getConnection()->prepare($sqlCreadas);
            $resultCreadas = $stmtCreadas->executeQuery(['usuarioId' => $usuarioId]);
            $dietasCreadas = $resultCreadas->fetchAllAssociative();

            return $this->json([
                'success' => true,
                'dietasAsignadas' => $dietasAsignadas,
                'dietasCreadas' => $dietasCreadas,
                'totalAsignadas' => count($dietasAsignadas),
                'totalCreadas' => count($dietasCreadas)
            ]);
        } catch (\Exception $e) {
            return $this->json([
                'success' => false,
                'error' => 'Error: ' . $e->getMessage()
            ], 500);
        }
    }

    #[Route('/dieta/{dietaId}/usuario/{usuarioId}', name: 'api_usuario_detalle_dieta', methods: ['GET'])]
    public function getDetalleDieta(int $dietaId, int $usuarioId, Request $request): JsonResponse
    {
        try {
            // ✅ Validar token
            $authHeader = $request->headers->get('Authorization');

            if (!$authHeader || !preg_match('/^Bearer\s+(.+)$/', $authHeader, $matches)) {
                return $this->json([
                    'success' => false,
                    'error' => 'Token no proporcionado'
                ], 401);
            }

            $token = $matches[1];
            $payload = $this->decodeJwt($token);

            if (!$payload) {
                return $this->json([
                    'success' => false,
                    'error' => 'Token inválido o expirado'
                ], 401);
            }

            // Buscar email en múltiples claims posibles (username, email, sub)
            $emailFromToken = $payload['username'] ?? $payload['email'] ?? $payload['sub'] ?? null;
            $usuarioFromDb = $this->entityManager
                ->getConnection()
                ->executeQuery(
                    "SELECT id FROM usuarios WHERE email = ?",
                    [$emailFromToken]
                )
                ->fetchOne();

            if (!$usuarioFromDb || (int)$usuarioFromDb !== (int)$usuarioId) {
                return $this->json([
                    'success' => false,
                    'error' => 'No autorizado'
                ], 403);
            }

            // Info básica de la dieta
            $sql = "
                SELECT 
                    d.id,
                    d.nombre,
                    d.descripcion,
                    d.calorias_totales,
                    d.proteinas_totales,
                    d.carbohidratos_totales,
                    d.grasas_totales
                FROM dietas d
                WHERE d.id = :dietaId
                AND d.asignado_a_usuario_id = :usuarioId
            ";

            $stmt = $this->entityManager->getConnection()->prepare($sql);
            $result = $stmt->executeQuery(['dietaId' => $dietaId, 'usuarioId' => $usuarioId]);
            $dieta = $result->fetchAssociative();

            if (!$dieta) {
                return $this->json(['success' => false, 'error' => 'Dieta no encontrada'], 404);
            }

            // Obtener platos por día
            $sqlPlatos = "
                SELECT 
                    dp.dia_semana,
                    dp.tipo_comida,
                    p.id as plato_id,
                    p.nombre as plato_nombre,
                    p.descripcion as plato_descripcion,
                    p.calorias_totales,
                    p.proteinas_totales,
                    p.carbohidratos_totales,
                    p.grasas_totales
                FROM dieta_platos dp
                INNER JOIN platos p ON dp.plato_id = p.id
                WHERE dp.dieta_id = :dietaId
                ORDER BY 
                    FIELD(dp.dia_semana, 'lunes', 'martes', 'miercoles', 'jueves', 'viernes', 'sabado', 'domingo'),
                    FIELD(dp.tipo_comida, 'desayuno', 'media_manana', 'almuerzo', 'merienda', 'cena', 'post_entreno'),
                    dp.orden
            ";

            $stmt = $this->entityManager->getConnection()->prepare($sqlPlatos);
            $result = $stmt->executeQuery(['dietaId' => $dietaId]);
            $platos = $result->fetchAllAssociative();

            // Agrupar por día
            $planSemanal = [
                'lunes' => [],
                'martes' => [],
                'miercoles' => [],
                'jueves' => [],
                'viernes' => [],
                'sabado' => [],
                'domingo' => []
            ];

            foreach ($platos as $plato) {
                $dia = $plato['dia_semana'];
                $momento = $plato['tipo_comida'];

                $sqlIngredientes = "
                    SELECT 
                        pa.cantidad_gramos,
                        a.id as alimento_id,
                        a.nombre as alimento_nombre,
                        a.calorias,
                        a.proteinas,
                        a.carbohidratos,
                        a.grasas
                    FROM plato_alimentos pa
                    INNER JOIN alimentos a ON pa.alimento_id = a.id
                    WHERE pa.plato_id = :platoId
                    ORDER BY pa.orden
                ";

                $stmtIng = $this->entityManager->getConnection()->prepare($sqlIngredientes);
                $resultIng = $stmtIng->executeQuery(['platoId' => $plato['plato_id']]);
                $ingredientes = $resultIng->fetchAllAssociative();

                $planSemanal[$dia][] = [
                    'momento_dia' => $momento,
                    'plato_nombre' => $plato['plato_nombre'],
                    'plato_descripcion' => $plato['plato_descripcion'],
                    'ingredientes' => $ingredientes,
                    'calorias_totales' => (float)$plato['calorias_totales'],
                    'proteinas_totales' => (float)$plato['proteinas_totales'],
                    'carbohidratos_totales' => (float)$plato['carbohidratos_totales'],
                    'grasas_totales' => (float)$plato['grasas_totales']
                ];
            }

            return $this->json([
                'success' => true,
                'dieta' => $dieta,
                'plan_semanal' => $planSemanal
            ]);
        } catch (\Exception $e) {
            return $this->json([
                'success' => false,
                'error' => 'Error: ' . $e->getMessage()
            ], 500);
        }
    }

    /**
     * Decodificar JWT usando clave pública
     */
    private function decodeJwt(string $token): ?array
    {
        try {
            $parts = explode('.', $token);
            if (count($parts) !== 3) {
                return null;
            }

            [$headerB64, $payloadB64, $signatureB64] = $parts;

            // Decodificar payload
            $payload = json_decode($this->base64UrlDecode($payloadB64), true);

            if (!$payload) {
                return null;
            }

            // Verificar expiración
            if (isset($payload['exp']) && $payload['exp'] < time()) {
                return null;
            }

            // Verificar firma
            $message = "$headerB64.$payloadB64";
            $signature = $this->base64UrlDecode($signatureB64);

            $publicKeyPath = __DIR__ . '/../../config/jwt/public.pem';
            if (!file_exists($publicKeyPath)) {
                return null;
            }

            $publicKey = openssl_pkey_get_public(file_get_contents($publicKeyPath));
            if ($publicKey === false) {
                return null;
            }

            $verified = openssl_verify($message, $signature, $publicKey, OPENSSL_ALGO_SHA256);

            if ($verified !== 1) {
                return null;
            }

            return $payload;
        } catch (\Exception $e) {
            return null;
        }
    }

    private function base64UrlDecode(string $data): string
    {
        $padding = strlen($data) % 4;
        if ($padding) {
            $data .= str_repeat('=', 4 - $padding);
        }
        return base64_decode(strtr($data, '-_', '+/'));
    }
    #[Route('/test-token', name: 'test_token', methods: ['GET'])]
    public function testToken(Request $request): JsonResponse
    {
        $authHeader = $request->headers->get('Authorization');

        return $this->json([
            'auth_header' => $authHeader,
            'has_auth' => $authHeader ? true : false
        ]);
    }

    #[Route('/debug-jwt', name: 'debug_jwt', methods: ['GET'])]
    public function debugJwt(Request $request): JsonResponse
    {
        $authHeader = $request->headers->get('Authorization');

        if (!$authHeader || !preg_match('/^Bearer\s+(.+)$/', $authHeader, $matches)) {
            return $this->json([
                'error' => 'No token found',
                'auth_header' => $authHeader
            ]);
        }

        $token = $matches[1];
        $parts = explode('.', $token);

        if (count($parts) !== 3) {
            return $this->json(['error' => 'Invalid token format']);
        }

        [$headerB64, $payloadB64, $signatureB64] = $parts;

        // Decodificar payload
        $payload = json_decode($this->base64UrlDecode($payloadB64), true);

        return $this->json([
            'success' => true,
            'payload' => $payload,
            'payload_keys' => array_keys($payload ?? []),
            'has_username' => isset($payload['username']),
            'has_email' => isset($payload['email']),
            'has_sub' => isset($payload['sub']),
            'username_value' => $payload['username'] ?? 'NO EXISTE',
            'email_value' => $payload['email'] ?? 'NO EXISTE',
            'sub_value' => $payload['sub'] ?? 'NO EXISTE'
        ]);
    }
}
